---
title: "Model Fitting"
output: html_document
---
## Referance
- http://idata8.com/rpackage/GWmodel/00Index.html(GWmodel 的函數簡單說明)

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## library the packages



```{r}
library(GWmodel)      ### GW models
library(dplyr)
library(sp)           ## Data management
library(car)          ## vif
library(spdep)        ## Spatial autocorrelation
library(RColorBrewer) ## Visualization
library(classInt)     ## Class intervals
library(raster)       ## spatial data
library(grid)         # plot
library(gridExtra)    # Multiple plot
library(ggplot2)      # Multiple plot
library(gtable)
library(GGally)       # 相關係數圖矩陣（scatter plot matrix）
library(maptools)
library(MASS)
library(tmap)
library(glmnet)      # For Lasso and Ridge
## ggplot for glmnet
library(ggplot2)
library(tidyr)
library(dplyr)
library(ggrepel)
```

## Function 

### pdf_Plot


```{r pdf_Plot}
pdf_plot <- function(x){
  g = ggplot()+
    geom_histogram(aes(x = x, y = ..density..), 
                   fill = '#557C55', alpha = 0.8)+
    geom_density(aes(x = x, y = ..density..), 
                 color = '#062C30', size = 1)+
    theme_bw()
  
  return(g)
}
```

```{r}

coeff2dt <- function(fitobject, s) {
  coeffs <- coef(fitobject, s) 
  coeffs.dt <- data.frame(name = coeffs@Dimnames[[1]][coeffs@i + 1], coefficient = coeffs@x) 

  # reorder the variables in term of coefficients
  return(coeffs.dt[order(coeffs.dt$coefficient, decreasing = T),])
}

```

## Load and tidy data

```{r Load data}
getwd()
```


```{r Load data}
path = '..\\..\\Roaming-Dogs-Data\\'

# Variable_df <- read.csv(paste0(path, "@Taiwan_sampling_village_variable\\Taiwan_sampling_village_variable.shp" ), fileEncoding = 'utf-8')
Variable_shp<-shapefile(paste0(path, "@Taiwan_sampling_village_variable\\Taiwan_sampling_village_variable.shp" ),encoding = 'utf-8')

Variable_shp@data[is.na(Variable_shp@data)] <- 0

Variable_shp@data$Nr = Variable_shp@data$Nr %>% as.integer()
Variable_df = Variable_shp@data
```

```{r}
colnames(Variable_df)
```

```{r Varaible name 01}
col_X = 
  c( "Cluster", # 分群
     "Hospital","Clinic", "Temple", "Ele","Junior" ,"Senior", "Train.stat", # 公共建設
     "Ele_stu", "Junior_stu" ,"Senior_stu", "Train.crow", # 人流
     "high_rat",   "mid_rat","low_rat", "M_F_RAT" , "P_DEN", "YOUN_DEP","OLD_DEP","AGING_IDX", # 人口統計(教育程度、人口密度...)
     "Income_mea","Income_sta","P_CNT") # 村里收入
col_y = c('Nr')
```

```{r 轉成數值}
for(i in c(col_X, col_y)){
  
  Variable_shp@data[i] = sapply(Variable_shp@data[i], function(x) as.numeric(x))
  Variable_df[i] = sapply(Variable_df[i], function(x) as.numeric(x))
}
```

### 轉成密度
```{r 轉成密度}
for(i in c('Hospital',  "Temple",  "Ele" ,"Junior" ,"Senior", "Train.stat",  "Clinic","Ele_stu", "Junior_stu" ,"Senior_stu", "Train.crow")){
  
  i_new = paste0(i, "_den")

  Variable_shp@data[i_new] = Variable_shp@data[i]/Variable_shp@data$Area_sqkm
  Variable_df[i_new] = Variable_df[i]/Variable_df$Area_sqkm
}

colnames(Variable_df)
```




```{r Varaible name 02}
col_X = 
  c( "Cluster", # 分群
     "Hospital_den" ,  "Temple_den",  "Ele_den" ,"Junior_den" ,"Senior_den", "Train.stat_den",  "Clinic_den", # 公共建設
     "Ele_stu_den" ,   "Junior_stu_den" ,"Senior_stu_den", "Train.crow_den",
     "high_rat","low_rat", "M_F_RAT" , "P_DEN", "YOUN_DEP","OLD_DEP","AGING_IDX", # 人口統計(教育程度、人口密度...)
     "Income_mea","Income_sta")
col_y= c('Nr')
```

### Scale the Data


```{r scale the data}

for (i in col_X[col_X != "Cluster"]){

    Variable_df[i] <- scale(Variable_df[i])
    Variable_shp@data[i] <-scale(Variable_shp@data[i])

}
```

```{r}
arrange(Variable_df[c("COUNTYNAME","TOWNNAME","VILLNAME",col_y)], Nr)
```

```{r Nr_den pdf}
pdf_plot((Variable_df$Nr+1))+xlab("log the density of Nr")
```


## Correlation
```{r correlation}
corr = cor(Variable_df[c(col_y,col_X)])
idx = abs(corr[,col_y])>.05
col_X_02 = names(corr[idx,col_y]) %>% tail(-1)

corr[idx,idx]
```

```{r scatter plot}

# ggpairs(Variable_df, columns =c(col_X_02,col_y)) 

```

## Global PCA 

- 沒有考慮地理加權

```{r}
data = Variable_df[c(col_X_02,col_y)]
class(data)

pca <- prcomp(~.,  #選擇變數 
              data = Variable_df[c(col_X_02)],  # 資料
              scale = TRUE)                          # 正規化資料
```

### 陡坡圖(Scree plot)-凱莎原則

```{r Scree Plot for PCA}
plot(pca,         # 放pca
     type="line", # 用直線連結每個點
     main="Scree Plot for PCA") # 主標題
```

### 累積解釋圖(Pareto plot)

從pca中取出標準差(pca$sdev)後再平方，計算variance(特徵值)

```{r Pareto plot}

# 從pca中取出標準差(pca$sdev)後再平方，計算variance(特徵值)
vars <- (pca$sdev)^2  

# 計算每個主成分的解釋比例 = 各個主成分的特徵值/總特徵值
props <- vars / sum(vars) 

print(props)

# 累加前n個元素的值
cumulative.props <- cumsum(props)  # 累加前n個元素的值
cumulative.props

ggplot()+
  geom_point(aes(x = c(1:length(cumulative.props)), y = cumulative.props))+
  ggtitle("累積解釋圖")
```

### New Variable

```{r }
col_PC = c()

for(i in c(1:4)){
  col_PC[i] = paste0("PC",i)
  Variable_shp@data[paste0("PC",i)] <- pca$x[, i]
  Variable_df[paste0("PC",i)] <- pca$x[, i]
}
```


-- PCA 先慢著用，先用 LASSO 或者Ridge 試試看 ------

## GLM possion with Ridge
- https://stats.stackexchange.com/questions/232666/should-i-use-an-offset-for-my-poisson-glm
- https://stats.stackexchange.com/questions/11182/when-to-use-an-offset-in-a-poisson-regression
- https://core.ac.uk/download/pdf/6656887.pdf


由于是發生數 case 服從 poisson 分布，而不是比例（密度）服從，所以最后以下方算是呈現：
$$
log(E(Y|x)) = log(exposure)+\theta'x
$$
證明：
$$
log(E(Y|x))-log(exposure) = log(\frac{E(Y|x)}{exposure}) = \theta'x
$$

### offset is area
```{r}
f = Nr~.
glm_po = glm(f,data = Variable_df[c(col_X_02, "Nr", "Area_sqkm")], family=poisson(link=log), offset = log(Area_sqkm) )
```

```{r}
summary(glm_po)
pdf_plot(glm_po$residuals)
```

```{r pdf_plot nb--regression residual scatter plot}
ggplot(Variable_df)+
  geom_point(aes(x = X, y = Y, color = glm_po$residuals))
```

### ridge and offset is Area
```{r}
set.seed(12345) # reproducible random numbers
X = Variable_df[col_X_02] %>% data.matrix(); y = Variable_df[col_y] %>% data.matrix(); off = Variable_df$Area_sqkm %>% log
cvfit = cv.glmnet(X, y, offset = off, family = "poisson", alpha = 0)

plot(cvfit)
```


### Ridge's Coefficients
```{r}
plot(cvfit$glmnet.fit,xvar ="lambda", label = T) 
```
```{r}
coef(cvfit, s = "lambda.min"); lambda.min = (cvfit$lambda.min)
coeffs.table <- coeff2dt(fitobject = cvfit, s = "lambda.min")
ggplot(data = coeffs.table) +
  geom_col(aes(x = name, y = coefficient, fill = {coefficient > 0})) +
  xlab(label = "") +
  ggtitle(paste("Lasso Coefficients with lambda",round(lambda.min,4))) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "none") 
```

```{r}
betas = as.matrix(cvfit$glmnet.fit$beta)
lambdas = cvfit$lambda
names(lambdas) = colnames(betas)

as.data.frame(betas) %>% 
tibble::rownames_to_column("variable") %>% 
pivot_longer(-variable) %>% 
mutate(lambda=lambdas[name]) %>% 
ggplot(aes(x=log(lambda),y=value,col=variable)) + 
geom_line() + 
geom_label_repel(data=~subset(.x,lambda==min(lambda)),
aes(label=variable),nudge_x=-0.5) +
ylab("Coefficient")+
geom_vline(aes(xintercept=log(cvfit$lambda.min)), color="#990000", linetype="dashed")+
theme_bw()#+
# scale_x_log10()
```

### offset is population
```{r}
f = Nr~.
glm_po = glm(f,data = Variable_df[c(col_X_02, "Nr", "P_CNT")], family=poisson(link=log), offset = log(P_CNT) )
```
```{r}
summary(glm_po)
pdf_plot(glm_po$residuals)
```

```{r pdf_plot nb--regression residual scatter plot}
ggplot(Variable_df)+
  geom_point(aes(x = X, y = Y, color = glm_po$residuals))
```

## GWR-Possion
### Select bw

選擇出來的帶寬為 22 
```{r DW bw}
f = log(Nr_den+1)~.
DM <- gw.dist(dp.locat=data.matrix(((Variable_df[c('X', "Y")]))))



bw <- bw.ggwr(formula = f,  
                  data = Variable_shp[c(col_PC, col_y)],
                  approach = "AICc",
                  kernel = "gaussian",
                  dMat = DM )
bw #22
```


## GW Model 
- https://arxiv.org/ftp/arxiv/papers/1312/1312.2753.pdf
```{r GWR Model Fitting}
gwr.possion.model <- ggwr.basic(Nr~., 
                      data =Variable_shp[c(col_PC, col_y)],
                      family = "poisson",
                      bw = bw, 
                      kernel = "gaussian", 
                      adaptive = TRUE,
                      dMat = DM)
```

```{r GWR Model Fitting summary}
bgwr 
```

```{r GWR poisson residual}
gwr.possion.model$SDF$PC1_TV
```

```{r pdf_plot-- GWPR regression residual}
pdf_plot(gwr.possion.model$SDF$residual)
```

```{r map-- GWPR regression residual}
ggplot(Variable_df)+
  geom_point(aes(x = X, y = Y, color = gwr.possion.model$SDF$residual))
```

## Poisson Ridge Regression

- https://kknews.cc/zh-tw/news/k6vzymr.html
- https://kknews.cc/code/3avmnxg.html
- https://blog.csdn.net/computerme/article/details/50486937

```{r}
library(glmnet)
y = Variable_df$Nr
X = Variable_df[col_X_02] %>% data.matrix()
```

```{r}
Ridge.Poi<-glmnet(x=X,y=y,family = "poisson")#alpha = 0表示嶺迴歸,x,y不能有缺失值
# plot(x, xvar = c("norm", "lambda", "dev")  
plot(Ridge.Poi, xvar="dev", label=T)
# plot(Ridge.Poi) 
```
```{r}
print(Ridge.Poi) #第一列Df是非零係數的個數，第三列和第二列分別是λ以及該λ對應的解釋偏差百分比%dev
coef(Ridge.Poi,s=0.1)
plot(Ridge.Poi)
```

```{r}
Ridge.Poi.cv<-cv.glmnet(x=X,y=y,family="poisson",alpha=0,nfolds = 10)
plot(Ridge.Poisson)
```


